#!/usr/bin/env Rscript
# Alex GILLET-MARKOWSKA
#0.14
# alexandre.gillet-markowska@upmc.fr
####################################
suppressPackageStartupMessages(suppressWarnings(library(tcltk)))

## I. READ AND PROCESS INPUT
# This part reads, checks and process
# the input from Ulysse python algo.

debug = TRUE
debug = FALSE



opt <- options(show.error.messages=FALSE)
options <- commandArgs(trailingOnly = TRUE)


#print(options)

##### The .so file is generated by running R CMD SHLIB probamaxdist.c
##### Loading will fail unless compilation has been done on same system
##### This is needed by the function ComputePIS.fast
#dyn.load("~/ULYSSE.v1.0/probamaxdist.so")
#dyn.load(options[20])
cLib.so = options[20]
cLib.c = gsub(".so$", ".c", cLib.so)
cmd = paste("rm", cLib.so, "&& R CMD SHLIB", cLib.c, sep=" ")
tryCatch(dyn.load(cLib.so),error=function(e) system(cmd))

source(options[9])


if(length(options)<20){ 
	message("!!! The library statistics file is missing or incomplete !!!")
	try(stop(), silent=T)
	}

if(debug==TRUE) {print("intro1")}
if(debug==TRUE) {print(options)}
if(debug==TRUE) {print("FIN OPTIONS")}
#read parameters from input
IS.mean <- as.numeric(options[1])
IS.med <- as.numeric(options[2])
IS.mad <- as.numeric(options[3])
IS.sd <- as.numeric(options[4])
n <- as.numeric(options[5])
l <- as.numeric(options[6])
seuil = as.numeric(options[8])
tipe = options[10]
list_chr_length=options[11]
list_chr_names=options[12]
detectionFile=options[13]
dist.table.file <- options[14]
s.vals <- as.numeric(options[15])
seuil.fdr <- as.numeric(options[16])
RL <- as.numeric(options[17])
n.param <- as.numeric(options[18])

#print(seuil.fdr)
#print(IS.med)
#print(IS.mad)

#compute library parameters
d <- IS.med + n.param*IS.mad
if(debug==TRUE) {print(d)}

if(debug==TRUE) {print(tipe)}
if(debug==TRUE) {print(IS.med)}
#ISddist <- getISddist(IS.mean, 4*IS.mad)

if(IS.med>1000) {
  #print("get ISddist")
  if(debug==TRUE) {print(IS.med/10)}
  if(debug==TRUE) {print((IS.mad)/10)}
  ISddist <- getISddist(IS.med/10, 2*IS.mad/10)
  #if(debug==TRUE) {print((ISddist))}
  ISc <- (n.param*IS.mad)/10
  #print("end get ISddist")
} else {
    if(debug==TRUE) {print(IS.med)}
    if(debug==TRUE) {print(IS.mad)}
    ISddist <- getISddist(IS.med, 2*IS.mad)
    ISc <- n.param*IS.mad
}


#print(ISc)

#Process chromosome names and sizes read from input #PUT in a function
n.s <- as.data.frame(strsplit(list_chr_names, "SEP"))
names(n.s) <- "chr"
#n.n <- as.character(n.s$chr)
t.s <- as.data.frame(strsplit(list_chr_length, "SEP"))
names(t.s) <- "tailles"
t.n <- data.frame(chr=n.s$chr, tailles=t.s$tailles)

if(debug==TRUE) {print("intro2")}

#read dist.table file for library distribution
if(detectionFile!="ClusterLimitSize" && (tipe=="DEL" || tipe=="sINS")){ 
  dist.table <- tryCatch(read.table(dist.table.file, col.names = c("Freq", "chr.F", "chr.R", "mate.orient", "mate.dist" )), error=function(e) NULL)
  if(is.null(dist.table) == TRUE || length(dist.table$Freq) < 1){
    msg = paste("!!! Error: Dist.table file (", dist.table.file, ") is empty, no stats will be performed !!!", sep="")
    message(msg)
    stop() }} 


#Check if xdiff exists (only if dealing with inter chr events)
xdiff <- tryCatch(read.table(options[7], h=T, check.names = FALSE),error=function(e) NULL)
#if(is.null(xdiff) == TRUE && (tipe!="DEL" || tipe!="sINS" || tipe!="DUP" || tipe!="INV")){
if(debug==TRUE) {print(tipe)}
if(nrow(xdiff) == 0 && (tipe=="TN" || tipe=="INS" || tipe=="TR")){
  msg = paste("!!! Error: File with inter-chromosomal PS statistics (", options[7], ") is empty, no stats will be performed !!!", sep="")
  message(msg)
  stop()
}

#Check if xdiff exists (only if dealing with inter chr events)
intraPS <- tryCatch(read.table(options[19], h=T, check.names = FALSE),error=function(e) NULL)
if(is.null(intraPS) == TRUE && (tipe!="DEL" || tipe!="sINS" || tipe!="INTER")){
  msg = paste("!!! Error: File with intra-chromosomal PS statistics (", options[19], ") is empty, no stats will be performed !!!", sep="")
  message(msg)
  stop()
} 
#print(intraPS)
if(debug==TRUE) {print("intro3")}
#if(debug==TRUE) {print(xdiff)}


if(tipe=="INS" || tipe=="TN" | tipe=="TR"){
#NOT LOGICAL ==> CORRECT LATTER
#Pre-treat inter chromosomal PS stats for TR, TN and INS only
  xdiff <- cbind(data.frame(do.call(rbind, strsplit(as.character(xdiff$V1), "-"))), xdiff) #split chr pairs
  if(debug==TRUE) {print("xdiff1")}
  xdiff$X1len <- sapply(xdiff$X1, function(x) {getChrLen(x, t.n)}) #add chr1 length
  xdiff$X2len <- sapply(xdiff$X2, function(x) {getChrLen(x, t.n)}) #add chr2 length
  if(debug==TRUE) {print("xdiff2")}
  if(debug==TRUE) {print(head(xdiff))}
  xdiff <- subset(xdiff, X1len!=0 & X2len!=0) #remove strange chromomes (not needed any more)
  if(debug==TRUE) {print("xdiff3")}
  
  xdiff$d <- d #add d to inter chr file
  if(debug==TRUE) {print("xdiff4")}
  xdiff$l <- l  #add genome length to inter chr file
  if(debug==TRUE) {print("xdiff5")}
} else if(length(xdiff[,1])==0){
#if(tipe=="DUP" | tipe=="INV"){
  xdiff = data.frame(V1=1, V2=1, X1len=1, X2len=1, d=d, l=l, PS=2)
} else {
  xdiff$PS <- 2  #add minps to inter chr file
  xdiff$d <- d #add d to inter chr file
  xdiff$l <- l  #add genome length to inter chr file
#xdiff <- data.frame(PS= 2)  #add minps to inter chr file
}


if(debug==TRUE) {print("intro4")}

#Checks if the SV type we are trying to deal with is supported
if((tipe %in% c('DUP', 'DEL', 'INV', 'TR', 'INS', 'TN', 'sINS'))==FALSE){
		msg= paste("!!! Error", tipe, "is not supported for statistical analysis !!!", sep=" ")
		message(msg)
		on.exit(options(opt))
		stop() }
if(debug==TRUE) {print("intro4.1")}
#Checks the detection file (and exit if empty)
if(detectionFile != "ClusterLimitSize") {
  if(debug==TRUE) {print("intro4.2")}
  detection <- tryCatch(read.csv2(detectionFile, h=T, stringsAsFactors=FALSE, check.names = FALSE), error=function(e) NULL)
  if(debug==TRUE) {print("intro4.3")}
  if(is.null(detection) == TRUE){
                          msg = paste("!!! Warning: ", detectionFile, " is empty or not well formated. No stats will be done !!!")
	                        message(msg)
	                        stop()
	                      }
  if(debug==TRUE) {print("intro4.4")}
	detection$score <- NULL #remove score if they already exists (obselete)
  if(debug==TRUE) {print("intro4.5")}
  if(nrow(detection)==0) { 
		msg <- paste("!!! Warning: ", detectionFile, " is empty, no stats to do !!!") 
		message(msg) 
		on.exit(options(opt))
		stop() }
  #print(tipe)
  if(debug==TRUE) {print("intro4.6")}
  if(debug==TRUE) {print(detectionFile)}
	clusterAll=getClusterStats(detectionFile, tipe) #number of clusters of size n by pair of chr
  if(debug==TRUE) {print("intro4.7")}
  clusterAllINTER=getClusterStatsINTER(detectionFile, tipe) #number of clusters of size n by pair of chr
	#print(clusterAll)
  }

if(debug==TRUE) {print("intro5")}
##############################
######### OLD for debug
# IS.mean = 7303
# IS.med = 7303
# IS.sd = 63400
# IS.mad = 1500
# d = IS.mean + 6*IS.mad
# n=34000
# l=12000000
# cluster=30
# seuil =0.05
# list_chr_length="1090947SEP270148SEP576874SEP1531919SEP316617SEP813178SEP230208SEP439885SEP562643SEP924429SEP1078175SEP666454SEP745741SEP85740SEP948066SEP1091289SEP784334"
# list_chr_names="chr7SEPchr6SEPchr5SEPchr4SEPchr3SEPchr2SEPchr1SEPchr9SEPchr8SEPchr13SEPchr12SEPchr11SEPchr10SEPchr17SEPchr16SEPchr15SEPchr14"
##############################

#print("-------------------666--------------------")
#print(xdiff)




 ## II. THRESHOLD ESTIMATION FOR N(SV)<10,000
 # This part can set for all SV classes the minimal
 # SV cluster size (minps) in order to predict less
 # than 10000 SV.
 # This is justified in order to keep a functionnal
 # genome and improves calculation times.
 # This evaluation is particularely usefull for 
 # "durty" labraries like illumina Long Jumping 
 # Distance or some Mate-Pairs libraries).

if(detectionFile=="ClusterLimitSize"){  #For minps setting 
  	
  #print(xdiff)
  if(debug==TRUE) {print("avant fineMinPS.2")}
  if(debug==TRUE) {print(tipe)}
  if(debug==TRUE) {print(head(ISddist))}
  if(debug==TRUE) {print(ISc)}
  if(debug==TRUE) {print(l)}
  if(debug==TRUE) {print(d)}
  if(debug==TRUE) {print(n)}
  if(debug==TRUE) {print(seuil)}
  if(debug==TRUE) {print(head(xdiff))}
	fixeMinps.2(tipe, ISddist, ISc, l, d, n, seuil, xdiff)
  
  
} else{
  ## III. SV FILTERING
  # This part performs pval calculation for deletions
  # and other types of SVs (different binomial model
  # in both cases, see paper). pvalue cut-off for SV
  # filtering is then evaluated (FDR, 0.01) and SV are
  # then filtered.  
  
  ###### DUP INV DEL for filtering
	if(tipe=="DUP" | tipe=="INV" | tipe=="DEL" | tipe=="sINS"){
	  
		if(tipe=="DEL" | tipe=="sINS"){
      #Compute the empirical distribution of Insert sizes.
		  IS.emp <- GetISemp(dist.table, perc.clean = 1)
		  
      #read and clean detection file
			cur.del <- read.csv2(detectionFile, h=T, check.names = FALSE) #read detection file
			cur.del[["pval"]] <- NULL #clean detection file from eventual old pval
			cur.del[["SV_size_max"]] = cur.del[["SV_size_max"]]+IS.med    #SV_size_max does not contain the IS any more

      #For MP libraries, Fragment coverage is evaluated from nucleotide coverage (2*IS.med/ReadLength)
      #This is not needed for PE libraries
      #cat(IS.med)
      #cat("\n")
      #cat(RL)
			if(IS.med > 1000){
			  #cur.del[["cov"]] <- cur.del[["cov"]]*(2*IS.med/RL) 
        cur.del[["cov"]] <- cur.del[["cov"]]*(IS.med/(RL*3)) #ori
        pvals.del <-  Pvaldist(cur.del[["nbPS"]] , cur.del[["cov"]], cur.del[["SV_size_max"]], IS.emp)
			  #cur.del[["cov"]] <- cur.del[["cov"]]/(2*IS.med/RL) #replace the nucleotide coverage back
			  cur.del[["cov"]] <- cur.del[["cov"]]/(IS.med/(RL*3)) #replace the nucleotide coverage back # ori
			} else {
			  cur.del[["cov"]] <- cur.del[["cov"]]*(RL) #ori
			  pvals.del <-  Pvaldist(cur.del[["nbPS"]] , cur.del[["cov"]], cur.del[["SV_size_max"]], IS.emp)
			  cur.del[["cov"]] <- cur.del[["cov"]]/(RL) #ori
# 			  cur.del[["cov"]] <- cur.del[["cov"]]*(RL/5)
# 			  pvals.del <-  Pvaldist(cur.del[["nbPS"]] , cur.del[["cov"]], cur.del[["SV_size_max"]], IS.emp)
# 			  cur.del[["cov"]] <- cur.del[["cov"]]/(RL/5)
			}
			
		  cur.del[["SV_size_max"]] = cur.del[["SV_size_max"]]-IS.med  #correct SV_size_max (see lign 161)
      
      cur.del[["pval"]] <- pvals.del #add pvals to the detection file
      
      filterAndSaveFiles(cur.del, seuil.fdr, tipe, detectionFile) #filter with FDR and saves the files
			
		  		
		} else{
		###### DUP and INV for filtering
		#print(clusterAll)
    #dfpcomp=getAllpCOMP(tipe, l, d, ISddist, ISc, IS.sd, IS.mad, clusterAll)
       
    clusterAll.freq = getClusterAllDetailForINTRA(intraPS,detection, d, l, t.n, detectionFile, tipe, clusterAll )
    if(debug==TRUE) {print("DUP/INV filtering1")}
    if(debug==TRUE) {print(Sys.time())}
    allpcomp=getAllpCOMPINTRA.2(tipe, l, d, ISddist, ISc, IS.sd, IS.mad, clusterAll.freq, 0)
    if(debug==TRUE) {print(allpcomp)}
    if(debug==TRUE) {print("DUP/INV filtering2")}
    if(debug==TRUE) {print(Sys.time())}
    
    clusterAll.freq[["pcomp"]] <- allpcomp
    if(debug==TRUE) {print(clusterAll.freq)}
    
    #write.table(allpcomp, file="allpcomp.csv", col.names=F)
    #write.table(clusterAll.freq, file="clusterAll.csv", col.names=F)
    
    neu <- names(clusterAll.freq)
    neu[1] <- "(pair of) chromosome(s)"
    names(clusterAll.freq) <- neu
    detection3 <- merge(detection, clusterAll.freq, by = c("(pair of) chromosome(s)", "nbPS"))
    neu=names(detection3)
    neu[1]="chr"
    names(detection3)=neu
    detection3 <- detection3[with(detection3, order(chr, ID)), ] #sort nicely
    detection3 <- restoreName(detection3) #restores names
    neu[1]="(pair of) chromosome(s)"
    names(detection3)=neu
    #print(detection3)
    #write.table(clusterAll.freq, file="clusterAll.freq.csv", row.names =F)
    #write.table(detection3, file="detection3.csv",  row.names = F)
    #write.table(detection, file="detection.csv",  row.names = F)
    if(debug==TRUE) {print("DUP/INV filtering3")}
    if(debug==TRUE) {print(Sys.time())}
    
    probs = sapply(1:length(detection3[,1]), function(x) {
      #nbPS <- as.numeric(detection3[x,2])
      #pair <- detection3[x,1]
      #n <- as.numeric(detection3[x,19])
      
      nbPS <- as.numeric(detection3[x,"nbPS"])
      pair <- detection3[x,"(pair of) chromosome(s)"]
      #n <- as.numeric(detection3[x,"V2"])
      n <- as.numeric(detection3[x,"PSdisc"])
      
      pcomp <- as.numeric(detection3[x,"pcomp"])
      nbObs <- as.numeric(detection3[x,"freq"])
      
      
      if(tipe=="INV"){
        nbComb <- choose(n,round(2*nbPS))
      } else {
        nbComb <- choose(n,nbPS)
      }
      nbComb <- choose(n,nbPS)
      
      #pcomp <- as.numeric(detection3[x,21])
      #nbObs <- as.numeric(detection3[x,18])
      #if(debug==TRUE) {print(paste(nbPS, pair, n, pcomp, nbObs, nbComb, sep="]---["))}
      #if(debug==TRUE) {print(paste(nbObs, nbComb, pcomp, pbinom(nbObs, nbComb, pcomp, lower.tail=F), sep="]---["))}
      
      tryCatch(pbinom(nbObs, nbComb, pcomp, lower.tail=F), warning=function(w) 0)})
      
      #tryCatch(dbinom(nbObs, nbComb, pcomp), warning=function(w) 0)})
    
    if(debug==TRUE) {print("DUP/INV filtering4")}
    if(debug==TRUE) {print(Sys.time())}
    #sort like detection3
    detection = changeName(detection, "chr")
    detection <- detection[with(detection, order(chr, ID)), ] 
    detection <- restoreName(detection)
    
    #print(probs)
		detection[["pval"]] <- probs #add pvals to the detection file
    #write.table(detection, file="test.csv")
    #print(detection)
    #print(head(detection))
    filterAndSaveFiles(detection, seuil.fdr, tipe, detectionFile) #filter with FDR and saves the files
    }

	} else if(tipe=="INS" | tipe=="TR" | tipe == "TN"){
	  if(debug==TRUE) {print("INTER1")}
    #print(xdiff)
	  #add the number of discordant reads to the cluster stats clusterAll
    clusterAll.freq <- getClusterAllCleanForINTER(xdiff, detection, d, l, t.n, detectionFile, tipe, clusterAll)
	  ### clusterAll.freq <- getClusterAllCleanForINTER2(xdiff, detection, d, l, t.n, detectionFile, tipe, clusterAllINTER) #version with individual junctions
    #print(xdiff)
    #print(clusterAll)
    
	  if(debug==TRUE) {print("INTER2")}
	  #if(debug==TRUE) {print(clusterAll.freq )}
    #write.table(clusterAll.freq, file="cluster.csv",  row.names = F)
    #Get all pcomp and add it to the clusterstatistics
    allpcomp=getAllpCOMPINTER(tipe, l, d, clusterAll.freq, 0)
	  if(debug==TRUE) {print("INTER2.1")}
    if(debug==TRUE) {print(allpcomp)}
	  clusterAll.freq[["pcomp"]] <- allpcomp
	  
    
    neu = names(clusterAll.freq)
    neu[3]="chr"
    names(clusterAll.freq)=neu
    detectionN = changeName(detection, "chr")
	  if(debug==TRUE) {print("INTER3")}
    
	  #if(debug==TRUE) {print(head(detectionN ))}
    
    ## detectionN$nAB <- paste(detectionN$nbA, detectionN$nbB, sep="-") #version with individual junctions
	  #if(debug==TRUE) {print(head(detectionN ))}
  	detection3 <- merge(detectionN, clusterAll.freq, by = c("chr", "nbPS"))
	  ## detection3 <- merge(detectionN, clusterAll.freq, by = c("chr", "nAB")) #version with individual junctions
    detection3 <- detection3[with(detection3, order(chr, ID)), ] #sort nicely
    
    #print(head(detection3))
	  if(debug==TRUE) {write.table(detection3, file="detection3.csv",  row.names = F)}
    #print(head(detection3))
	  if(debug==TRUE) {print("INTER3")}
		probs = sapply(1:length(detection3[,1]), function(x) {
# 		  nbPS <- as.numeric(detection3[x,2])
# 		  pair <- detection3[x,1]
# 		  n <- as.numeric(detection3[x,22])
# 		  nbComb <- choose(n,nbPS)
# 		  pcomp <- as.numeric(detection3[x,25])
# 		  nbObs <- as.numeric(detection3[x,21])
		  nbPS <- as.numeric(detection3[x,"nbPS"])
		  pair <- detection3[x,"chr"]
		  #n <- as.numeric(detection3[x,"V2"])
		  n <- as.numeric(detection3[x,"PSdisc"])
		  nbComb <- choose(n,nbPS)
		  pcomp <- as.numeric(detection3[x,"pcomp"])
		  nbObs <- as.numeric(detection3[x,"freq"])
		  #if(debug==TRUE) {print(paste(nbObs , nbComb, pcomp, nbPS, pbinom(nbObs, nbComb, pcomp, lower.tail=F), sep="]---["))}
		  tryCatch(pbinom(nbObs, nbComb, pcomp, lower.tail=F), warning=function(w) 0)})
if(debug==TRUE) {print("INTER4")}
#print(probs)
		#sort like detection3
	 detection <- detectionN[with(detectionN, order(chr, ID)), ] 
	 detection <- restoreName(detection)
	 detection[["pval"]] <- probs
 
  #remove nAB before writing
  detection$nAB <- NULL
		
if(debug==TRUE) {print("INTER5")}
		#write.table(detection, file="detection.csv",  row.names = F)
   filterAndSaveFiles(detection, seuil.fdr, tipe, detectionFile) #filter with FDR and saves the files
    
        
	} else { #in case user specifies an unsupported SV type
		msg <- paste("error on SV type: ", tipe, " SV type is not supported", sep="")
		message(msg)
		on.exit(options(opt))
		stop()
	}
}






